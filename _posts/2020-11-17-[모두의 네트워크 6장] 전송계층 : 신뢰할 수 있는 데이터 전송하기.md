---
layout: post
title: "[모두의 네트워크 6장] 전송계층 : 신뢰할 수 있는 데이터 전송하기"
categories:
  - Network
tags:
  - 모두의 네트워크
---

##  **전송 계층의 역할** 

- 전송 계층의 역할 : 라우터의 라우팅 기능을 통해 데이터를 전송하더라도 라우팅 정보가 잘못되거나, 다중의 라우터를 경유하는 도중 라우터에 문제가 생기거나 패킷이 손상되어 데이터가 목적지에 도착하지 못할 수도 있다. 여태 배운 물리 계층, 데이터 링크 계층, 네트워크 계층은 목적지에 데이터를 보내기는 하지만 데이터가 손상되어도 아무런 처리를 하지 못한다. 이때 전송 계층은 목적지에 신뢰할 수 있는 데이터를 전달하기 위해 필요하다. 
- 전송 계층은 다음과 같은 기능을 수행함으로써 목적지에 신뢰할 수 있는 데이터를 전달한다.
  - 오류를 점검하는 기능 : 전송 계층의 기능 중 하나로, 오류가 발생하면 데이터를 재전송하도록 요청한다. 
  - 전송된 데이터의 목적지가 어떤 애플리케이션인지 식별하는 기능 : 전송되는 데이터가 어떤 애플리케이션에서 사용하는 데이터인지 판단한다. 

##  **연결형 통신과 비연결형 통신** 

전송 계층의 특징을 간단히 설명하면 신뢰성/정확성과 효율성으로 구분할 수가 있다.

- 신뢰성/정확성 : 데이터를 목적지에 문제 없이 전달하는 것
  - 연결형 통신 : 신뢰할 수 있고 정확한 데이터를 전달하는 통신으로 상대편과 확인해가면서 통신한다.
- 효율성 : 데이터를 빠르고 효율적으로 전달하는 것이다.
  - 비연결형 통신 : 효율적으로 데이터를 전달하는 통신으로 상대편을 확인하지 않고, 일방적으로 데이터를 전송한다.

일반적으로는 연결형 통신을 사용하나, 동영상을 전송할 때에는 비연결형 통신을 사용한다. 동영상보다는 신뢰성보다는 효율성이 중요시되기 때문이다. 또, 전송 계층의 연결형 통신 프로토콜에는 TCP(Transition Control Protocol)가 사용되고, 비연결형 통신 프로토콜에는 UDP(User Datagram Protocol)가 사용된다.

------

##  **TCP의 구조** 

TCP로 전송할 때 붙이는 헤더를 TCP 헤더라고 하고, 이 TCP 헤더가 붙은 데이터를 세그먼트(segment)라고 한다. IP 헤더와 마찬가지로 TCP헤더도 계층을 지나며 캡슐화와 역캡슐화가 진행된다.

이 TCP 헤더에는 다음과 같이 목적지까지 데이터가 제대로 전송되기 위한 정보를 갖고 있다.

| 출발지 포트 번호(16비트) | 목적지 포트 번호(16비트) |                  |                     |
| ------------------------ | ------------------------ | ---------------- | ------------------- |
| 일련 번호(32비트)        |                          |                  |                     |
| 확인응답 번호(32비트)    |                          |                  |                     |
| 헤더 길이(4비트)         | 예약 영역(6비트)         | 코드 비트(6비트) | 윈도우 크기(16비트) |
| 체크섬(16비트)           | 긴급 포인터(16비트)      |                  |                     |
| 옵션                     |                          |                  |                     |

연결형 통신은 상대방에게 데이터를 전송하기 전에 해야하는 작업이 있다. 데이터를 전송하려면 먼저 연결(connection)이라는 가상의 독점 통신로를 확보해야 한다. 이 연결을 확립한 후에 데이터를 전송할 수 있다.

TCP 헤더의 코드 비트 부분는 연결 제어 정보가 기록되는 곳이다. 

| URG  | ACK  | PSH  | RST  | SYN  | FIN  |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    |

각 비트 별로 역할이 있으며 초깃값은 0이고, 비트가 활성화되면 1이 된다. 연결을 확립하려면 이 중 SYN과 ACK가 필요하다. SYN은 연결 요청, ACK는 확인 응답을 뜻한다. 

##  **3-way 핸드셰이크란?** 

연결(connection)은 SYN과 ACK를 사용하여 확립할 수가 있다. 신뢰할 수 있는 연결을 하려면 데이터를 전송하기 전에 패킷을 교환하는데, 세 번 확인해야 한다.

- 전송 측 : 연결 확립 요청(SYN) 
  수신측에게 연결 확립 허가를 받기 위한 요청(SYN)을 보낸다.
- 수신 측 : 연결 확립 응답(ACK) + 연결 확립 요청(SYN) 
  수신측이 허가한다는 응답을 회신하기 위해 연결 확립 응답(ACK)를 보내는 동시에 전송측에게 반대로 데이터 전송 허가를 받기 위한 연결 확립 요청(SYN)을 보낸다.
- 전송 측 : 연결 확립 응답(ACK)
  수신측의 요청을 받은 전송측은 허가한다는 응답으로 연결 확립 응답(ACK)을 보낸다.

이처럼 데이터를 보내기전에 연결을 확리하려고 패킷 요청을 세번 교환하는 것을 3-way 핸드 셰이크(3-way handshake)라고 한다. 

데이터를 전송한 후, 연결을 끊을 때에도 이를 위한 요청을 서로 주고 받아야한다. 이때 FIN과 ACK가 사용되는데, FIN은 연결 종료를 뜻하고 다음과 같이 요청을 교환한다.

- 전송 측 : 연결 종료 요청(FIN)
- 수신 측 : 연결 종료 응답(ACK)
- 수신 측 : 연결 종료 요청(FIN)
- 전송 측 : 연결 종료 응답(ACK)

연결을 확립할 때에는 SYN을 사용하고, 연결을 종료할 때에는 FIN을 사용한다. 

------

##  **일련번호와 확인 응답 번호의 구조** 

3-way 핸드셰이크가 끝나면 실제 데이터를 보내거나 상대방이 받을 때는 TCP 헤더의 일련번호와 확인 응답 번호를 사용한다.

- 일련번호 : TCP가 데이터를 분할해서 전송할 때, 송신 측에서 전송하는 데이터가 몇 번째 데이터인지 수신측에게 알려주는 역할
- 확인 응답 번호 : 수신 측이 몇번째 데이터를 수신했는지 송신측에 알려주는 역할로, 수신 측에서 송신 측에게 다음 번호의 데이터를 요청하는 데에도 사용

데이터를 전송하기 전 단계에서 3-way 핸드셰이크로 연결 수립이 이뤄질 때, 이번 통신에 사용하는 일련번호인 3001번과 확인 응답 번호인 4001번이 결정된다.

- 송신측 : 200바이트 데이터 송신
  일련 번호 - 3001
  확인 응답 번호 - 4001
- 수신측 : 3001번 데이터를 받았습니다. 3201번을 보내주세요
  일련 번호 - 4001
  확인 응답 번호 - 3201
- 송신측 : 200바이트 데이터 송신
  일련 번호 - 3201
  확인 응답 번호 - 4001
- 수신측 : 3201번 데이터를 받았습니다. 3401번을 보내주세요.
  일련 번호 - 4001
  확인 응답 번호 - 3401

이러한 과정을 데이터의 전송이 완료될때까지 반복하는 것이다. 이 과정을 통해 일련번호와 확인 응답 번호를 사용하여 데이터가 손상되거나 유실되어도 데이터를 재전송할 수 있게 한다. 이러한 과정을 재전송 제어라고 한다. 만약 데이터가 전송하는 도중에 오류가 발생하면, 일정 시간 대기 후에 재전송한다.

## **윈도우 크기란?** 

조금 전에 설명한 것은 세그먼트(데이터) 하나를 보낼 때마다 확인 응답을 한 번 반환하는 방식이었다. 그런데 이 방식은 매번 확인 응답을 기다리므로 효율이 낮다. 따라서 세그먼트를 연속해서 보내고 난 다음에 확인 응답을 반환하면 효율이 높아진다.

이 방식이 가능한 이유는 수신 측에서 받은 세그먼트를 일시적으로 보관하는 버퍼가 있기 때문에 가능하다. 이 버퍼 덕분에 세그먼트를 연속해서 보내도 수신 측이 대응할 수 있고, 확인 응답의 효율도 높아진다.

그런데 수신 측에게 데이터가 대량으로 전송될 경우, 버퍼에 데이터가 넘치는 상황이 발생하기도 하는 데, 이것을 오버플로우(overflow)라고 한다.

오버플로우가 발생하지 않도록 수신측은 버퍼의 한계 크기를 알고 있어야 하며, 이 버퍼의 한계 크기는 TCP 헤더의 윈도우 크기(window size) 값에 해당한다. 윈도우 크기는 얼마나 많은 용량의 데이터를 저장해 둘 수 있는 지를 나타낸다. 다른 말로는, 확인 응답을 일일히 하지 않고 연속해서 송수신할 수 있는 최대 데이터 크기라고도 할 수 있다.

윈도우 크기의 초깃값은 3-way 핸드셰이크를 할 때 판단한다. 

- 송신측 : 연결 확립 요청
  일련 번호 - xxxx, 확인 응답 번호 - xxxx, 윈도우 크기 - 3000
- 수신측 : 연결 확립 응답 + 연결 확인 요청
  일련 번호 - xxxx, 확인 응답 번호 - xxxx, 윈도우 크기 - 2000

위의 3-way handshake에서 송신측 컴퓨터의 한계 값이 3000바이트고, 수신측 컴퓨터의 한계 값이 2000바이트임을 서로에게 전달함으로써 두 측은 상대방의 윈도우 크기를 알 수가 있다. 이로써 두 컴퓨터는 데이터를 전송할 때, 상대방 컴퓨터에서 오버플로우가 발생하지 않도록 세그먼트를 윈도우 크기에 맞춰 보낼 수가 있게 된다.

------

##  **포트 번호의 구조** 

 

전송 계층은 연결 확립, 재전송 제어, 윈도우 제어 기능을 통해 데이터를 정확하게 보내는 TCP 통신을 가능케 했다. 그러나 전송 계층은 이 기능 이외에도, 전송된 데이터의 목적지가 어떤 애플리케이션인지 구분하는 역할을 수행한다.

이 기능을 수행하기 위해 TCP 헤더에는 출발지 포트 번호(source port number)와 목적지 포트 번호(destination port number)가 필요하다. 즉, TCP 헤더에 포트 번호가 있기 때문에 애플리케이션을 구분할 수가 있는 것이다.

포트 번호는 0~65535 범위의 값을 지정할 수가 있다.

- 0~1023 - 잘 알려진 포트(well-known ports) : 주요 프로토콜이 사용하도록 예약되어있는 포트 번호로 일반적으로는 서버측 애플리케이션에서 사용되고 있다.
- 1024 - 예약은 되어있으나 사용되지는 않는 포트 번호
- 1025 이상 - 랜덤 포트 : 클라이언트 측의 송신 포트로 사용되는 번호

서버에서 자주 사용되는 애플리케이션 번호는 다음과 같다.

| 애플리케이션 | 포트 번호 |
| ------------ | --------- |
| SSH          | 22        |
| SMTP         | 25        |
| DNS          | 53        |
| HTTP         | 80        |
| POP3         | 110       |
| HTTPS        | 443       |

이처럼 애플리케이션은 각각 포트 번호가 있어서 다른 애플리케이션과 구분되고, 데이터를 전송할 때에는 상대방의 IP주소가 필요하지만, 어떤 애플리케이션이 사용되고 있는 지 구분하려면, TCP 포트 번호가 필요하다. 

웹 브라우저로 접속 할 때 서버 측에서는 포트 번호를 정해둬야 하지만, 클라이언트 측은 정하지 않아도, 웹 브라우저가 임의의 포트를 자동으로 할당한다. 

------

##  **UDP의 구조**  

UDP는 비연결형 통신이라서 데이터를 전송할 때, TCP처럼 시간이 걸리는 확인 작업을 일일히 하지 않는다. UDP는 TCP와 달리 효율성을 중시하는 프로토콜이므로 TCP와 같은 신뢰성과 정확성을 요구하면 효율일 떨어지기 때문이다. 

UDP의 장점은 데이터를 효율적으로 빠르게 보내는 것이므로, 스트리밍 방식으로 전송하는 동영상 서비스와 같은 곳에 사용된다. 동영상 TCP 데이터 통신으로 전송하면 수신을 확인하는 데 시간이 너무 오래 걸려서 동영상을 원활하게 볼 수가 없기 때문이다. 

##  **UDP 헤더란?** 

UDP에서는 UDP 헤더가 붙은 데이터를 UDP 데이터그램이라고 한다. 헤더의 구조는 다음과 같다.

| 출발지 포트 번호(16비트) | 목적지 포트 번호(16비트) |
| ------------------------ | ------------------------ |
| 길이(16비트)             | 체크섬(16비트)           |

보다시피, UDP는 TCP보다는 신뢰성과 정확성이 필요하지 않기 때문에 헤더 정보는 이것만으로 충분하다. 또한 TCP는 여러번 확인 응답을 보내면서 전송하나, UDP는 효율성과 빠른 속도가 중요하므로 상대방을 확인하지 않고, 연속해서 데이터를 보낸다.

UDP를 사용하면 같이 랜에 있는 컴퓨터나 네트워크 장비에 데이터를 일괄로 보낼 수 있는데, 이것을 브로드 캐스트(broadcast)라고 한다. 반면, TCP는 3-way 핸드셰이크와 같이 확인 응답을 하나씩 보내야 하므로, 브로드 캐스트와 같이 불특정 다수에게 보내는 통신에는 적합하지 않다. 즉, UDP에서의 브로드캐스트는 목적지에 관계없이 랜에서 일괄적으로 보내지만, TCP는 목적지를 지정하지 않으면 안되기 때문에 일괄 통신을 할 수가 없다.