---
layout: post
title: "[유혁 교수의 운영체제] 3.운영체제 구조"
categories:
  - OS
tags:
  - 운영체제 구조


---

# 운영체제 구조

### System Structure

- 운영체제는 규모가 매우 크고 복잡한 소프트웨어
  - 설계 시 소프트웨어의 구조를 신중히 고려해야 함
- 좋은 설계를 통해 쉬워지는 것들
  - 개발(Develop)
  - 수정(Modify and Debug)
  - 유지 보수(Maintain)
  - 확장(Extend)
- 디자인 목표 중에 좋은 것이란?
  - 좋은 다자인에 대한 기준이 절대적이지 않으며, 이는 설계하고자 하는 시스템의 용도와 관계가 있다.

### OS Design Principle

- Mechanism
  - Determine **how** to do something
    - **어떻게** 할 것인가?
  - Ex : concrete alogorithms, data structures
- Policy
  - Decide **what** to be done
    - **무엇**이 되게 할 것인가?
  - High level direction
    - 네트워크 패킷과 파일 데이터 처리 **Priority** (예전에는 배치 시스템을 먼저 돌렸으나, 요즘에는 사용자가 작업중인 어플리케이션을 우선으로 작업을 수행시킨다.)
    - use mechanism
- Mechanism과 Policy를 분리함으로써 운영체제 설계를 보다 module화 할 수 있음
  - 규모가 아주 큰 OS를 설계할 때에는 어떤 Mechanism과 Policy를 선택할지 염두에 두면서 큰 소프트웨어를 작은 모듈들로 쪼개는 것이 중요하다.
  - 모듈화의 예시 - layering

### Layering

- OS의 복잡도를 낮추기 위한 방안
- Layer는 정의가 명확한(well-defined) 함수들로 이루어짐
  - 용도와 목적이 분명히 정의된 함수들로 이뤄져 있다.
- 하나의 Layer는 인접한 Layer와만 통신
  - 위, 아래에 인접한 layer만과 통신하며 2단계 이상 건너띈 layer와는 직접적으로 통신하지 않음
    - 여기서 통신이란 넓게는 메시지를 주고 받는 의사소통을 의미하기도 하지만, 여기서는 호출 가능 여부를 말한다. 
    - 2단계 이상 건너띈 layer와 직접 통신이 불가능하므로, 설계의 복잡도가 낮아진다.
      - 밑의 그림에서 B 모듈을 D 모듈로 바꾼다고 할 때, D가 A와 C가 요구하는 인터페이스와 시멘틱스(Semantics)를 잘 맞춰주기만 해도 B를 완벽히 대체할 만한 조건을 갖출 수 있다.
      - 각 모듈 사이의 결합도가 낮다.
- 설계의 복잡도를 낮출 수는 있으나, 그로 인해서 overhead가 발생함
  - 굳이 거치치 않아도 되는 계층이 있다해도 반드시 이 계층을 지나가도록 설계될 경우 overhead가 발생한다.
  - overhead가 너무 커질 경우, design principle을 일부 무시하고, 계층을 건너띌 수 있도록 설계하기도 한다.
  - -> 복잡도와 overhead 사이의 trade-off를 계산하여 principle을 엄격히 따를 것인지 아닌지 여부를 결정한다.
- ex) 7-layers of the OSI model

![]({{site.url}}/assets/images/43.png) 

> **Interface에서 Syntax와 Semantics**
>
> - Syntax - 문법
>   - 함수의 데이터 타입, Array의 크기, Arguements의 개수 등
> - Semantics - 의미
>   - 함수의 용도, 동작 

### Layering vs Modularity

- Modularity
  - 여러 개의 함수를 묶은 모듈들을 병렬적으로 나열한 후, 각 모듈 사이의 인터페이스를 통해서 서로 통신할 수 있도록 설계된 구조
  - 각 모듈 사이의 접점(인터페이스)이 arbitrary하고, 넓다.
  - 접점이 넓을수록 보안에 취약할 가능성이 크다.
  - ex) process management, memory management - 이런 모듈들은 서로 간의 결합도가 높고, 각 모듈의 abstraction 정도가 높아, Layering을 적용하기가 힘들다.

- Layering의 장점
  - Modularity보다 표준화(common)된 인터페이스 설계
  - abstraction 정도가 낮은 네트워크에서 주로 사용된다. 코드를 단계별로 엄격하게 stacking을 하기 수월하기 때문이다. 
  - Layer의 수정이 다른 layer와 독립적임

![]({{site.url}}/assets/images/44.png)

### 불완전한 Layering

- Layering 원칙을 지키지 않은 예시 : MS-DOS
  - Application이 BIOS를 직접 호출할 수 있도록 했다. 즉, 어플리케이션이 임의로 시스템을 fail시킬 수 있었다는 것이다.

- Layering 원칙을 지킨 예시
  어떤 경우에서도 어플리케이션이 커널을 crash해서는 안된다. 커널과 어플리케이션 사이에는 큰 barrier를 두고 Layering을 시키는 principle이 도입되어야만 완전한 Layering이라고 할 수 있다.

![]({{site.url}}/assets/images/45.png)

### Kernel 내의 모듈들

- 커널 내의 시스템들은 모두 아래 그림과 같이 모듈화되어있다.
- 각 모듈들은 하드웨어와 연결되기 위한 인터페이스를 갖고 있다.
  - ex) DKI(Device Kernel Interface), HAL(Hardware Abstraction Layer)
    - HAL에 관한 설명은 다음 글 참조
      https://hee-jin506.github.io/os/2021/04/04/OS-HAL.html
  - 인터페이스가 필요한 이유 : 하드웨어와 OS를 분리하여 하드웨어의 종류와 상관없이 OS가 하드웨어를 안정적으로 운영할 수 있어야 하기 때문
    - 인터페이스가 잘 지원되지 않았을 때에는 하드웨어를 바꿀 때마다 커널을 다시 컴파일하거나 해당 하드웨어를 지원하는 OS의 버전을 찾아야 했다. 인터페이스의 Syntax와 Semantics가 모두 공개되어 그것에 맞게 프로그래밍만 하면 어떤 하드웨어 위에서도 OS가 돌아갈 수 있게 된 것은 90년대 후반부터였다.

![]({{site.url}}/assets/images/46.png)

### CPU의 실행 모드(mode)

 MS-DOS가 불완전한 Layering을 설계한 것은 경로를 단축하여 지름길을 내준 것도 있지만, 한편으로는 하드웨어 기술이 CPU의 실행모드를 구분하지 못했기 때문도 있다. 사용자(application)와 kernel이 서로 다른 권한(privilege execution)을 가지지 않는다면, 중간 계층에서 아무리 막으려고 해도 어플리케이션은 얼마든지 커널로 점프가 가능했다는 것이다. 커널은 하드웨어에 대한 접근이 가능한 시스템이니만큼, 어플리케이션은 절대로 직접적으로 커널로 점프할 수 없도록 막아야 했다. 따라서 운영체제와 어플리케이션의 권한을 나눠야한다는 결론에 도달했다. 이전까지는 CPU는 연산 같은 단순한 기능을 하는 수행 모드 하나만 갖고 있었으나, 현재는 최소한 두가지 이상, 많게는 7개까지 다양한 실행 모드를 갖는다.

- CPU의 2가지 이상의 실행 모드
  - System protection을 위해서 필요
    - 실행 모드의 권한에 따라 접근할 수 있는 메모리, 실행 가능한 명령어가 제한됨
      - 멀티프로그래밍에서의 스위칭을 어플리케이션이 할 수 있도록 한다면?
  - 각각의 모드 별로 권한(privilege)이 설정됨
  - Hardware 지원이 필요
    - Intel:  ring 0~3
      - Kernel - ring 0, app - ring 3

![]({{site.url}}/assets/images/47.png)

### User mode와 kernel mode 비교

다양한 CPU의 실행모드가 존재하지만 크게는 User mode와 kernel mode로 나뉠 수 있다.

- Kernel mode
  - 모든 권한을 가진 실행 모드
  - 운영체제가 실행되는 모드
  - Privilege 명령어 실행 및 레지스터 접근 가능
    - ex) I/O 장치 제어 명령어, memory management register - CR3
- User mode
  - Kernel 모드에 비해 낮은 권한의 실행 모드
  - 어플리케이션이 실행되는 모드
  - Privilege 명령어 실행은 불가능 - 하드웨어적으로 막혀있다.
    - 네트워크도 하드웨어, 즉 자원이라고 할 수 있는데, 이 네트워크를 사용할 때에도 커널 모드에서만 사용이 가능하므로 어플리케이션이 인터넷에 연결되려고 할 때마다 스위칭이 필요하다.
- 실행 모드 전환(execution mode switch) - 멀티프로그래밍에서 다룬 스위칭과는 상이한 개념 
  - CPU의 실행 모드 설정은 시스템 보호가 목적 
  - User mode에서 실행 중인 어플리케이션이 Kernel mode의 권한을 갖는 서비스를 받기 위한 방법이 필요!

> Q : 교수님 그러면 cpu가 kernel mode로 작동하다가 user mode로 작동하는 것을 반복하는 것인가요 아니면 cpu의 일부분은 kernel mode로 할당되어 작동하고 다른 일부분은 user mode로 할당되어 작동하는 것인가요? 
> A : 간단하게는 CPU 전체의 실행모드가 전환된다고 생각하는 것이 좋다. 그러나 나중에는 context 안에서는 개념을 배우게 될텐데, 엄밀히는 하나의 context 안에서 실행모드가 전환된다고 하는 것이 옳다. 

### 시스템 콜

- User mode에서 Kernel mode로 진입하기 위한 통로
  - 커널에서 제공하는 protected 서비스를 이용하기 위하여 필요
    - Open(2) : a file or device
    - Write(2) : to file or device
    - Msgsnd(2) : send a message
    - Shm(2) : attach shared memory

