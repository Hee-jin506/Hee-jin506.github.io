---
layout: post
title: "[유혁 교수의 운영체제] 2.운영체제 개요"
categories:
  - OS
tags:
  - 운영체제 개요

---

# 운영체제 개요

### 컴퓨터의 기원

- Compute + er : 과거에는 계산을 하기 위해서 사람을 고용했지만, 그 역할을 기계가 대신하기 시작한 것이 컴퓨터의 기원이라고 볼 수 있다.

- 컴퓨터가 구체적으로 형태를 띠기 시작한 것은 `2차 세계대전`이었다.

  - 암호 해석
  - 미사일 탄도 분석
  - 물리 계산

  등의 목적으로 기계가 동원되기 시작하면서 컴퓨터가 시작되었다.

### Hand-operated System

- 1950년대 초반
  - 당시 컴퓨터는 현재의 컴퓨터에 비해 매우 원시적이었다.
  - 프로그램은 기계적인 스위치를 이용하여 1bit 단위로 컴퓨터에 입력되어 실행되었다.
    - 진공관 기반 - 집채만한 크기, 많은 열 방출
- 1950년 대 중반
  - 모든 프로그램은 기게어로 쓰여졌다.
    어셈블리어 조차도 기계어는 아니다. 기계어는 문자 그대로 바이너리의 형태이다.
  - 플러그 보드(Plug-board)에 와이어링(wiring)을 통해 컴퓨터의 기능을 제어
    file 개념이 없었기 때문에 플러그 보드는 컴퓨터의 전원이 꺼지면 유지되지 않았다. 따라서 매번 기계어를 다시 쳐야 했다.
  - 프로그래밍 언어 및 운영체제라는 존재가 없음
    - 영속적인 저장장치가 없음 - 매번 프로그램을 다시 입력해야 했다.
- 1960년 대 초반
  - 펀치카드가 등장
    ![]({{site.url}}/assets/images/34 .png)
    다음과 같이 미리 카드에 작성된 펀치 라인을 컴퓨터에 제출하면 그것이 컴퓨터 안에서 프로그램이 되어 메모리에 적재되고 수행이 되었다. 
  - 프로그래밍한 카드로 컴퓨터 구동
    - 플러그 보드 대체

### Mainframe - 일괄처리(Batch)

- Business machinery로써 쓰이면서 가치가 발생
  - 계산을 하는데 주로 사용되기 시작함
  - 교량(Bridge) 설계
- 일괄 처리 - 아주 단순한 OS 개념
  - 일단 시작한 job은 끝나냐 다음 job이 수행됨
  - Punch card를 제출하면, 메모리에 적재, 수행의 순서로 진행
  - 결과를 받기까지 중간에 No user interaction : 수행 중간에 사용자의 임의로 결과를 확인하거나, 중단이 불가능하다.
  - 사람이 job을 scheduling함

- CPU는 빈번히 idle(대기) 상태로 전환됨
  - 기계적인 IO 장치와 전기 장치인 CPU 사이에 현격한 속도 차가 존재
    따라서 대부분의 시간을 CPU는 대기하고 있어야 한다. 참고로, CPU의 대기 시간은 최적화 가능 여부를 따질 수 있는 큰 기준이 된다. CPU가 대기 상태인 시간이 많다면 최적화할 영역이 많다는 것을 뜻한다. CPU가 늘 saturate된 상태라면 최적화를 하더라도 큰 소용이 없을 수 있다.
    - 프로그램을 메모리에 올리는 시간(loading)이 사람이 Punch Card를 프로그램에 제출하는 시간을 포함하기에 엄청난 손실이 있을 수 밖에 없었다.

### Automatic Job Sequecing - 좀 더 나은 OS

- 사람의 관여 없이 여러 개의 프로그램을 컴퓨터에서 순차적으로 실행
- 이전 작업이 종료되자 마자 다음 작업을 실행하기 때문에, 일괄 처리(batch)보다 성능이 향상됨
  사람의 의해서 생기는 CPU의 대기 시간이 절약된다.
  - 일괄처리
    - 사람이 직접 스케줄링
  - Automatic Job Sequencing
    - 스케줄링을 담당하는 소프트웨어에서 프로그램 실행 
- IO에 의해 CPU가 유휴 상태로 전환되는 문제는 해결 X
  - 과거에 문서를 출력할 때에는 프린터가 출력을 모두 완료할 때까지 워드 프로그램은 중단되어있었다. 프린터가 출력을 완전히 완료해야만 CPU는 다음 동작을 이어 수행할 수 있었다. 이처럼 IO과정에서 CPU가 유휴 상태로 바뀌는 비효율을 해결하기 위한 또다른 방안을 고려해야 했다.

![]({{site.url}}/assets/images/35.png) 

### Spooling - 초기 해결책

- Simultaneous Peripheral Operation On-Line
  - 프린터 spooling
    - 인쇄할 문서를 디스크나 메모리의 버퍼에 로드
    - 프린터는 버퍼에서 자신의 처리 속도(분단위)로 인쇄할 데이터를 가져옴

즉, CPU는 프린터 버퍼에 데이터를 전송하는 작업이 끝나면 바로 다음 동작을 이어 수행할 수가 있게 되었다. 

![]({{site.url}}/assets/images/36.png) 

- IO와 Computation을 동시에 진행할 수 있음
  - 프린터가 인쇄하는 동안 컴퓨터는 다른 작업을 수행할 수 있음
    이 당시 프린터가 문서를 출력하는 속도가 매우 느렸으므로 엄청나게 많은 시간을 절약할 수가 있었다.
- Spooling을 통해서 사용자는 여러 개의 인쇄 작업을 프린터에 순차적으로 요청할 수 있음
  - 이전 작업의 종료를 기다리지 않고, 버퍼에 인쇄 작업을 로드하여 자신의 인쇄 작업을 요청함
    즉, 서로 다른 출력 작업을 두 번 요청할 경우, 두 번째 요청은 전에 요청된 문서의 출력이 완료될 때까지 기다리지 않고, 버퍼에 출력할 데이터를 로드하기만 하면 된다는 것이다.

참고로, 문서 출력을 요청한 후에 장치관리자에서 프린트 상태를 보면 스풀링이라는 단어가 나타나는 것을 확인할 수 있는데, 출력할 문서를 프린터 버퍼에 복사하는 중이라는 뜻이다.

- 여전히 Spooling을 도입할 때에도 배치 프로그램이 전제였다. 여전히 Job(현재에는 프로그램의 개념과 유사하다)은 요청된 순서대로 메모리에 올라가서 작업이 모두 완료될 때까지 CPU를 점유했다가 모두 완료되면 그제서야 다음 작업이 메모리에 올라와서 수행되는 형태를 취하고 있었다. 스풀링을 통해 IO 시간을 대폭 줄였지만 여전히 이 정책은 비효율적이고 느렸다.

### Multiprogramming

- 배치 프로그램의 비효율성을 줄이기 위해, 사람들은 메모리에 여러개의 Job을 올리는 방법을 고안했다. 이것이 Multiprogramming이었다.

- 2개 이상의 작업을 동시에 실행
  - 운영체제는 여러 개의 작업을 메모리에 동시에 유지
    배치 프로그램 당시에는 메모리가 하나의 프로그램을 올릴 정도의 크기였지만, 기술이 발전하면서 메모리가 더욱 켜저 하나 이상의 Job을 올릴 수 있게 되었다.
  - 현재 실행중인 작업이 IO를 할 경우, 다음 작업을 순차적으로 실행
  - 스케줄링이 도입됨 : first-come, first-served
    메모리에 올라간 다양한 작업에 관해서 CPU를 점유하는 Job을 전환해줄 주체가 필요했고, 이것을 위한 별도의 공간과 작업이 OS의 스케줄링 기능으로 발전하게 된다. 

![]({{site.url}}/assets/images/37.png) 

- Multiprogramming의 목적
  - CPU 활용도 증가
    - idle을 최소화
      IO과정에서 발생하는 CPU idle 시간(ex - 사용자의 키보드 입력 시간)을 CPU에게 다른 작업을 수행시킴으로써 절약할 수 있다.

- 단점
  - 사용자는 여전히 실행 중인 작업에 대해서는 관여할 수 없다.

![]({{site.url}}/assets/images/38.png) 

> IO란?
> Input과 Output의 약자로 CPU와 별도로 하드웨어가 동작하는 과정이며, 컴퓨터 및 주변 장치에 대하여 데이터를 전송하는 프로그램이다.

- 배치와 