---
layout: post
title: "[유혁 교수의 운영체제] 9. Synchronization"
categories:
  - OS
tags:
  - 컴퓨터 구조
---

# Synchronization

### 동기화란

- **공유 데이터**에 대한 **동시 접근**은 데이터의 일관성(consistency)를 해치는 결과를 낳을 수 있다.
  - Race Condition 
    - 공유 데이터에 대해 여러 프로세스가 **동시에 접근, 변경을 시도**하는 상황으로 **일관성이 보장되지 않는 상황** 
- 데이터 일관성을 유지하기 위해서는 수행하는 프로세스들이 **순차적(serializing을 통해)으로 데이터를 접근**하게 만드는 기법이 필요하다 
  - 이것을 **동기화(synchronization)**라고 함
- OS뿐만 아니라 딥러닝에서도 동기화 과정은 필요하다. 딥러닝에는 모델을 학습시키는 수많은 프로세스들이 존재하는데, 이 프로세스들이 작업을 수행하면서 중간중간에 동기화를 해주며 모델을 업데이트해줘야 한다. 이 과정 없이는 모델이 정상적으로 통합되지 않는다.

### 예제

- 은행의 입출금 문제 1000원의 잔고가 남아있을 때, 500원의 입금과 500원의 출금이 동시에 일어날 경우, 그 결과는?

- 두 프로세스 

  ```
  < Process A : 입금 처리>
  … //기타 관리 코드
  Balance = Balance + 500;
  … //종료
  ```

  ```
  < Process B : 출금 처리>
  … //기타 관리 코드
  Balance = Balance - 500;
  … //종료
  ```

- Balance 가 공유되고 concurrent 하게 수행하는 경우

### 구체적으로 보면

```
< Process A >
Register1 = Balance
Register1 = Register1 + 500
Balance = Register1
```

```
< Process B >
Register2 = Balance
Register2 = Register2 - 500
Balance = Register2
```

- 인터럽트로 인하여 execution interleaving :

```
T0: A process execute Register1=Balance [Register1=1000]
T1: A process execute Register1=Register1 + 500 [Register1=1500]
T2: B process execute Register2=Balance [Register2=1000]
T3: B process execute Register2=Register2 - 500 [Register2= 500]
T4: A process execute Balance =Register1 [Balance =1500]
T5: B process execute Balance =Register2 [Balance = 500]
```

- 최종적으로 500의 잔고가 남게 된다. 또는 Execution interleaving 순서에 따라 1500이 될 수도 있다. 즉, **결과를 예측할 수 없다는 문제가 생긴다** – **race condition !**

### 지금까지 배운 내용 중에서 동기화가 필요한 부분

- Thread programming 
  - **Data section** is shared 
- Shared memory 
  - Multiple processes can access 
- 커널
  - 커널 thread(execution flow)들끼리 커널의 자료구조가 공유된다.
  - **Data structures** shared

### Critical section

- 동기화 문제를 Critical Section으로 모델링(복잡한 디테일들을 단순화) 
- Critical section 이란 
  - 여러 프로세스들이 공유하는 **데이터에 접근하는 코드 영역**
    - 위의 예제에서는 balance에 접근하는 코드가 해당된다.
  - 한 번에 **오직 하나의 프로세스만이 critical section에 진입**해야 함 
    - 예: 은행 계좌의 Balance를 consistent하게 유지할 수 있음 
- Critical Section을 사용하여 모델링하면: 
  - entry section - critical section에 진입해도 되는지 확인 후 진입
  - critical section - 작업 수행
  - exit section - critical section에서 나온 후, 다른 프로세스가 들어갈 수 있도록 특정 작업 수행
  - remainder section - critical section과 관련 없는 작업들

### Critical Section 해결 조건들

- Critical Section 문제를 해결하는 알고리즘은 아래와 같은 세 가지 조건을 **<u>모두</u>** 만족해야 함 
  - **Mutual Exclusion (상호 배제)** - MUTEX
    - 만약 프로세스 A가 critical section에 진입해 있다면, **다른 모든 프로세스(priority와 상관 x)는 진입할 수 없어야 함** 
  - Progress 
    - critical section에 진입하려는 프로세스가 존재한다면, **그 중에서 한 프로세스는 critical section에 진입할 수 있어야 함** 
  - Bounded Waiting 
    - 어떤 프로세스가 **Critical section에 진입할 때까지 걸리는 시간에 “limit”이 존재**하여야 함

> **Corner case**
>
> 같은 환경에서 항상은 아니지만 종종 발생할 가능성이 있는 예외 상황을 말한다. 
> ex) 한번이라도 어떤 프로세스도 critical section에 진입을 못 하는 경우가 발생한다면 Corner case로 반드시 예외 처리를 해줘야 한다.

### 두 프로세스를 위한 알고리즘

- Shared variables: 

  ```
  int turn = 0; // 초기화 
                // turn = 0 일 때, P0 가 critical section에 진입 가능 
  ```

- Process P0 

  ```
  while (turn != 0) ; //waiting (entry section)
  	critical section
  turn = 1;           // exit section
  	remainder section
  ```

- Process P1 

  ```
  while (turn != 1) ; //waiting (entry section)
  	critical section
  turn = 0;           // exit section
  	remainder section
  ```

- 불만족 조건 : progress, bounded waiting 

  - 두 프로세스의 수행 순서가 alternate 안되면 진행 안됨 
    - P0, P0, P0 이면, 두 번째 P0 부터 멈추게 됨 (turn=1)
  - 정해진 dictate대로(P0-P1-P0-P1...) 프로세스가 수행되지 않을 경우에 progress가 만족되지 않음

### 개선된 알고리즘 – 두개의 flag 이용

- Shared variables: 

  ```
  boolean flag[2]; // flag [0] = flag [1] = false 로 초기화 
  								 // flag [0] = true일 때, P0 이 critical section에 진입 
  								 // flag [1] = true일 때, P1 이 critical section에 진입 
  ```

- Process P0 

  ```
  flag[0] = true;
  while (flag[1]) ; //waiting (entry section)
  	critical section
  flag[0] = false;  // exit section
  	remainder section
  ```

- Process P1

  ```
  flag[1] = true;
  while (flag[0]) ; // waiting (entry section)
  	critical section
  flag[1] = false;  // exit section
  	remainder section
  ```

- 만족 조건 : mutual exclusion 

- 불만족 조건 : progress, bounded waiting 

  - 두 프로세스가 동시에 flag[] 를 true 로 하면, Deadlock이 걸린다. 이것은 Corner case에 해당한다.

### Peterson solution

- Shared variables 

  ```
  int turn; 
  boolean flag[2]; // flag[0] = flag[1] = false 로 초기화
  ```

- Process P0

  ```
  flag [0] = true;
  turn = 1;
  while (flag [1] && (turn == 1)) ;
  	critical section
  flag [0] = false;
  	remainder section
  ```

- Process P1 

  ```
  flag [1] = true;
  turn = 0;
  while (flag [0] && (turn == 0)) ;
  	critical section
  flag [1] = false;
  	remainder section
  ```

- 만족 조건 : mutual exclusion, progress, bounded waiting

  - 두 프로세스가 동시에 수행되더라도, turn 값에 의하여 결정됨

### Peterson Solution의 한계

- Peterson solution의 확장은 가능한가? 
  - 3개 이상의 프로세스에서는 어떻게 구현할 것인가 
  - 확장된 알고리즘의 증명은 어떻게 할 수 있나 
  - 어떤 경우에도 동작함을 보여야 
- 일반적으로 이러한 증명은 NP 문제임 
  - 증명이 되더라도 매우 복잡함

### 초기 해결책

- Critical section에 들어가면서 **Interrupt를 disable함**
  - Interleaving 방지 
- **사용자 프로그램이 interrupt를 control하는 것은 바람직하지 않음**
  - 커널이 사용자 프로그램에 의해 제어되는 것은 보안면에서 위험
- **커널을 critical section 으로 만듦** (Many to One)
  - process as protection boundary 
  - **커널에 들어갈 때 interrupt disable**함 
  - 커널 전체가 **거대한 critical section**으로 처리함 
- Scalability 문제점 
  - 프로세스의 숫자가 많아 질 때 문제가 생긴다 – 대기시간 길어짐
  - **커널 multithreading 도입**(Many to Many, One to One)

### 하드웨어 솔루션

- 인터럽트가 아닌 다른 방법이 필요함
  - 인터럽트는 하드웨어에 의해서 발생하는데, 이를 소프트웨어적으로 처리하려고 하니, 동기화 문제가 잘 해결되지 않음
  - 소프트웨어보다는 하드웨어에서 어떤 처리를 통해 문제를 간단히
- 명령어(instuction-하드웨어와 소프트웨어의 경계)로 처리하면 알고리즘이 매우 간단하게 됨 
  - acquire lock (instruction)
  - critical section 
  - release lock (instruction)
  - reminder section 
- **동기화를 위한 instruction**이 도입됨

### Synchronization Instruction

- CPU에서 **원자적(atomically)으로 수행되는 명령어(instruction)** 이용 

  - **원자적**이란? 
    - 원자(atom) : 쪼갤 수 없는 단위
    - 명령어가 수행되는 동안 **인터럽트 발생 못함 (uninterruptible)** 
      - 어떤 instruction이 CPU의 5clock이 걸리는 작업이라면, 이 작업이 수행되는 5clock동안은 인터럽트가 발생할 수 없다.
      - 그런데 인터럽트는 어쨌든 Asynchronal하게 발생하는 이벤트인데, instruction 도중에 발생하는 인터럽트는 어떻게 처리?
        - instruction이 수행되는 동안에 프로세서는 하드웨어를 dispatch하지 않고 pending하고 있다가 instruction이 끝나고 다음 instruction이 시작하기 전에 인터럽트는 initiate한다.
      - 인터럽트가 interleaving(코드의 사이사이에 끼면서 데이터를 overwrite하는 것)의 원인이기 때문 

- Test and Set 명령어

  - 다음 명령어를 하나의 instuction으로 정의하면 이 함수 내부의 코드(원래는 어셈블리어로 되어있어야 함)를 실행하는 동안에는 interrupt가 발생하지 않는다.
  - C언어를 어셈블리어로 바꾸는 명령어 = `cc -s`

  ```
  boolean TestAndSet(boolean *target) {
  	boolean rv = *target;
  	*target = true;
  					// 명령어 내에서 implicit하게 true를 write
  	return rv;
  }
  ```

> Q : CISC 구조가 RISC 구조는 instruction과 어떤 관계인가요?
> A : RISC에서는 CISC와 달리 곱셈을 덧셈을 여러번 수행하는 방식으로 구현한다. 이 말은 즉, RISC는 곱셈을 원자적으로 수행하지 않겠다는 뜻이다. 
>
> Q : atomic instruction을 지원하지 않는 하드웨어에서는 완벽한 동기화를 하는 방법이 없는건가요?
> A : 없는 것은 아니다. 그런데 문제는 프로세스가 늘어날 수록 발생할 수 있는 case가 기하급수적으로 늘어나서 어떤 Corner case도 없도록 하려면 아주 복잡한 알고리즘을 짜야 한다는 문제가 생긴다.
>
> Q : test and set 명령어가 수행되는 도중에는 인터럽트가 발생되지 않는다고 하였는데, 명령어 수행 도중 갑자기 전원이 차단되는 등의 상황이 발생되는 경우는 어떻게 되나요?
> A : 이러한 상황은 피할 수 없는 인터럽트이므로 NMI(Non-Maskable Interrupt)라고 한다. Test and Set 같은 명령어는 전원이 나가버리면 더 이상 interrupt를 한다안한다의 의미조차 없다. 시스템이 서버리는 것이다.