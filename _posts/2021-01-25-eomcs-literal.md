---
layout: post
title: "[자바 문법] 리터럴"
categories:
  - Eomcs
tags:
  - 자바 문법

---

> - 2020-07-22 일자 수업 내용
> - [eomcs/eomcs-java](https://github.com/eomcs/eomcs-java) src/main/com/eomcs/lang/ex03
> - 자바의 정석 Chap2

# 리터럴

리터럴은 자바 언어로 표현된 값을 말한다. 자바에서 제공하는 리터럴 종류에는 다음과 같은 것들이 있다.

- **정수** 리터럴

  > **8, 16, 2진수 작성법**
  >
  > - 8진수는 숫자 맨 앞에 0을 적어서 작성한다.
  >
  > - 16진수는 숫자 맨 앞에 0x를 적어서 작성한다.
  >
  > - 2진수는 숫자 맨 앞에 0b를 적어서 작성한다.

  ```java
  System.out.println("-------- 정수 리터럴");
  System.out.println(78); // 10진수
  System.out.println(+78);
  System.out.println(-78);
  System.out.println(0116); // 8진수
  System.out.println(0x4e); // 16진수
  System.out.println(0b01001110); // 2진수
  ```

- **부동소수점** 리터럴

  ```java
  System.out.println("-------- 부동소수점 리터럴");
  System.out.println(3.14);
  System.out.println(31.4e-1);
  ```

- **논리** 리터럴

  ```java
      System.out.println("-------- 논리 리터럴");
      System.out.println(true);
      System.out.println(false);
  ```

  

- **문자** 리터럴

  ```java
      System.out.println("-------- 문자 리터럴");
      System.out.println('가');
  ```

- **문자열** 리터럴

  ```java
      System.out.println("-------- 문자열 리터럴");
      System.out.println("오호라 코딩스쿨!");
  ```

___

## 정수 리터럴

### 자릿수 표기

정수를 읽기 쉽도록 `_`를 숫자 사이에 삽입할 수 있다.

```java
    System.out.println(12783406);
    System.out.println(1278_3406);
    System.out.println(12_783_406);
```

`_`는 숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.

```java
    System.out.println(_12783406); 
    System.out.println(12783406_);

    // error!
```

자릿수 표기를 위한 `_`사용 규칙은 **2, 8, 16 진수**에도 동일하게 적용된다.

```java
    System.out.println(077);
    System.out.println(0_77);
    System.out.println(07_7);

    System.out.println(_077); // error!
    System.out.println(077_); // error!

    System.out.println(0b1100100);
    System.out.println(0b110_0100);
    System.out.println(0b1_1_0_0_1_0_0);

    System.out.println(0b_1100100); // error!
    System.out.println(0b1100100_); // error!

    System.out.println(0xffaa);
    System.out.println(0xff_aa);

    System.out.println(0x_ffaa); // error!
    System.out.println(0xffaa_); // error!
```

### 메모리 크기에 따른 표기법

정수를 저장할 메모리의 크기를 지정할 수 있다. 메모리의 크기에 따라 표현할 수 있는 정수의 크기가 다르다.

- 4 바이트 정수
  숫자에 접미사를 붙이지 않으면, 기본적으로 4 바이트 크기의 메모리에 저장되는 정수를 표현한다. 4 바이트로 표현할 수 있는 정수의 범위는 **-2^31^~ 2^31^-1**이다.

  ```java
      System.out.println(2147483647); // 4바이트 양의 정수 최대값
      System.out.println(-2147483648); // 4바이트 음의 정수 최소값
  ```

  이 메모리 크기를 초과하면 컴파일 오류가 발생한다.

  ```java
      System.out.println(2147483648); // error!
      System.out.println(-2147483649); // error!
  ```

- 8 바이트 정수
  4 바이트 메모리를 초과하는 정수 값을 표현할 떄 사용하며, 접미사 L 또는 l을 붙인다. 보통은 소문자  l이 숫자 1과 헷갈리기 때문에 대문자를 사용한다. 8 바이트로 표현할 수 있는 정수의 범위는 **-2^63^~ 2^63^-1**이다.

  ```java
      System.out.println(2147483648L); 
      System.out.println(-2147483649L); 
  ```

4 바이트 또는 8 바이트 정수의 최대값과 최소값을 외우기 번거롭기 때문에 자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 랩퍼 클래스에서 스태틱 필드로 값을 제공한다.

```java
    System.out.println(Integer.MAX_VALUE); // 2147483647
    System.out.println(Integer.MIN_VALUE); // -2147483648
    System.out.println(Long.MAX_VALUE); // 9223372036854775807
    System.out.println(Long.MIN_VALUE); // -9223372036854775808 
```

둘은 같은 값이라고 해도 차지하는 메모리의 크기가 다르다.

```java
    System.out.println(100); // 4바이트 크기의 정수 값 
    System.out.println(100L); // 8바이트 크기의 정수 값
```

### 메모리에 저장하는 방법

컴퓨터에서는 값을 저장할 때 전기 신호(예: RAM) 또는 자기 신호(예: HDD)로 저장한다. 값은 비트로 표현되고, 각 비트는 전기가 있거나 없거나 두 가지 상태로 구분된다. 비트의 두 가지 상태를 표현하기 위해서 2진수가 사용된다. 따라서 값을 메모리에 저장하려면 2진수로 표현될 수 있어야 한다.

### 정수를 2진수로 표현하는 방법

- 부호-절댓값(Sign-Magnitude)
  부동 소수점에서 가수부를 저장할 때 사용된다. 맨 왼쪽 1비트를 부호 비트로 사용되며 양수는 0, 음수는 1로 표현된다. 나머지 비트는 절댓값으로 저장된다.

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>+0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-0</td>
      <td>1000 0000</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1111 1101</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1111 1110</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1111 1111</td>
    </tr>
  </table>

  단점

  - 두 개의 0(+0, -0)이 존재한다.
  - 양수와 음수를 더했을 때 옳지 않은 값이 나온다.
    예) 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010 (-2)
  - 뺴기를 처리하는 컴퓨팅 회로를 별도로 설계해야 한다.

  장점

  - 이해하기 쉽다

- 1의 보수(Ones' Complement)
  음수의 모든 비트를 양수의 반대 값으로 바꾼다.

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>+0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-0</td>
      <td>1111 1111</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1111 1110</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1000 0010</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1000 0000</td>
    </tr>
  </table>

  단점

  - 두 개의 0이 존재한다.

  장점

  - 양수와 음수를 더하면 원래 값보다 1 작은 수가 나오는 경우가 발생한다.
    예) 5 + (-3) = 0000 0101 + 1111 1100 = 0000 0001 = 1

- 2의 보수(Two's complement)
  자바에서 음수를 저장하는 방법으로 1의 보수의 단점을 해결했다. 음수 0을 없앰으로써 8비트 기준 -128까지 표현이 가능하다.
  2의 보수를 만드는 방법

  1. 모든 비트를 반대 값으로 만든 다음 1을 더한다.
     0010 1001 => 1101 0110 =>1101 0111
  2. 오른쪽에서부터 1을 찾아, 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
     0010 100**1** => **1101 011**1
  3. 2^n(8비트라면 2^8 = 256)에서 음수 값만큼 뺀다.
     41 => 256 - 41 = 215 = 1101 0111

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1111 1111</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1000 0011</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1000 0010</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>-128</td>
      <td>1000 0000</td>
    </tr>
  </table>

  장점

  - 양수와 음수의 덧셈이 정상 작동한다.
  - 음수 0이 없다.

- K-초과(Excess-K)
  부동 소수점의 지수부(exponent)를 저장할 때 사용한다. 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation)이라고도 한다. K를 바이어스 값이라고 부르며, 표현하려는 값에 더할 때 사용한다.
  표현하려는 값 + 초과 값(K) = 결과
  바이어스 값(K)를 구하는 공식
  `K = 2^(비트수 - 1)`

  <table>
    <tr>
      <td>127</td>
      <td>1111 1111(128 + 127)</td>
    </tr>
    <tr>
      <td>126</td>
      <td>1111 1110(128 + 126)</td>
    </tr>
    <tr>
      <td>125</td>
      <td>1111 1101(128 + 125)</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1000 0001(128 + 1)</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0000 0000(128 + 0)</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>0111 1111(128 + (-1))</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>0000 0010(128 + (-126))</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>0000 0001(128 + (-127))</td>
    </tr>
    <tr>
      <td>-128</td>
      <td>0000 0000(128 + (-128))</td>
    </tr>
  </table>

  >  IEEE 부동소수점 표준에서는 다음 공식을 사용한다.
  > `K = 2^(비트수 - 1) - 1`

  장점

  - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖기 때문에 작은 값에서 큰 값으로 정렬되는 결과를 낳는다. 
  - 모든 비트가 정렬되므로 값을 비교할 때 속도가 빠르다.

### 자바에서 정수를 메모리에 저장하는 방법

`2의 보수`를 사용하여 정수 리터럴을 표현한다. 정수 리터럴은 각각 4바이트와 8바이트 크기의 메모리를 차지하므로 다음과 같이 메모리에 저장된다.

예시)
23  = 0000 0000 0000 0000 0000 0000 0001 0111
-23 = 1111 1111 1111 1111 1111 1111 1110 1001

____

## 부동소수점 리터럴

> **부동소수점(Floating Point)이란?** 
> [실수](https://ko.wikipedia.org/wiki/실수)를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, [유효숫자](https://ko.wikipedia.org/wiki/유효숫자)를 나타내는 가수(假數)와 소수점의 위치를 풀이하는 지수(指數)로 나누어 표현한다. 
> 출처: [https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90#:~:text=%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B8%E9%BB%9E,%E6%8C%87%E6%95%B8)%EB%A1%9C%20%EB%82%98%EB%88%84%EC%96%B4%20%ED%91%9C%ED%98%84%ED%95%9C%EB%8B%A4](https://ko.wikipedia.org/wiki/부동소수점#:~:text=부동소수점(浮動小數點,指數)로 나누어 표현한다).

### 표기법

부동소수점 리터럴은 자바에서 다음과 같이 표현 가능하다.

- 10진수

```java
System.out.println(3.14);
```

- Exponential 기호 사용
  e 기호를 사용하면 소수점의 위치를 조정할 수 있다. 소수점의 위치를 이처럼 움직인다고 해서 부동소수점이라고 부른다. e는 대문자 혹은 소문자로 모두 표기가 가능하다.

```java
    System.out.println(0.0314e2); // 0.0314 * 10의2승 = 3.14
    System.out.println(0.314e1); // 0.314 * 10의1승 = 3.14
    System.out.println(31.4e-1); // 31.4 * 10의-1승 = 3.14
    System.out.println(314e-2); // 314 * 10의-2승 = 3.14
```

### 메모리 크기에 따른 표기법

정수 리러털과 마찬가지로 부동소수점 리터럴도 저장할 메모리의 크기를 지정할 수 있다. 메모리의 크기에 따라 표현할 수 있는 부동소수점의 크기가 다르다.

- 4 바이트
  숫자 맨 뒤에 f 또는 F를 붙인다. 주로 소문자를 많이 붙인다. 4 바이트로 저장가능한 값의 범위는 1.4 x 10^-45^ ~ 3.4 x 10^38^이지만 정밀도는 7자리기 때문에, 그 이상으로는 정확한 수를 표현할 수 없다.

  ```java
      System.out.println(3.14f);
      System.out.println(3.14F);
  ```

- 8 바이트
  숫자 맨 뒤에 d 또는 D를 붙인다. 생략을 해도 된다. 8 바이트로 저장가능한 값의 범위는 4.9 x 10^-324^ ~ 1.8 x 10^308^이지만 정밀도는 15자리기 때문에, 그 이상으로는 정확한 수를 표현할 수 없다.

  ```java
      System.out.println(3.14);
      System.out.println(3.14d);
      System.out.println(3.14D);
  ```

정수 리터럴과 마찬가지로 자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 랩퍼 클래스에서 스태틱 필드로 값을 제공한다.

```java
    System.out.println(Float.MAX_VALUE); // 3.4 x 10^38
    System.out.println(Float.MIN_VALUE); // 1.4 x 10^-45
    
    System.out.println(Double.MAX_VALUE); // 1.8 x 10^308
    System.out.println(Double.MIN_VALUE); // 4.9 x 10^-324
```

### 유효자릿수

정수처럼 메모리 크기에 따라 표현할 수 있는 부동소수점의 범위가 다르다. IEEE754 명세에 따라 2진수로 변환되므로 저오학하게 소수점 이하 얼마까지 정의할 수 없다. 대신 `유효자릿수`라는 방식으로 대략적으로 값의 범위를 표현한다.

4바이트(float) 부동소수점의 유효자릿수는 소수점을 빼고 7자리이므로 7자리 숫자까지는 거의 정상 작동한다.

```
    System.out.println(999.9999f); // 999.9999
    System.out.println(999999.9f); // 999999.9
    System.out.println(9.999999f); // 9.999999
```

유효자릿수가 7자리를 넘어가는 경우 값이 잘려서 저장될 수가 있다.

```java
    System.out.println(987654321.1234567f); // 9.8765434E8
    System.out.println(9.876543211234567f); // 9.876543
    System.out.println(987654321123456.7f); // 9.876543E14
```

8바이트(double) 부동소수점의 유효자릿수는 소수점을 빼고 15자리이므로 15자리 숫자까지는 거의 정상 작동한다.

```java
    System.out.println(987654321.1234567); // 9.876543211234567E8
    System.out.println(9.876543211234567); // 9.876543211234567
    System.out.println(987654321123456.7); // 9.876543211234568E14
```

유효자릿수가 15자리를 넘어가는 경우 값이 잘려서 저장될 수 있다.

```java
    System.out.println(987654321.12345678); // 9.876543211234568E8
    System.out.println(9.8765432112345678); // 9.876543211234567
    System.out.println(987654321123456.78); // 9.876543211234568E14

```

유효자릿수가 7, 16자리를 넘지 않더라도 부정확하게 저장되는 경우가 가끔 있다.

```java
    System.out.println(7 * 0.1); // 0.7000000000000001
```

이러한 오류가 발생하는 이유는 IEEE-754 규격에 따라 부동소수점을 2진수로 바꾸다보면 정확하게 2진수로 떨어지지 않는 경우가 있기 때문이다. 

### 부동소수점을 2진수로 표현하는 방법

실수 값을 부동소수점 방식으로 저장하려면 1과 0으로 변환해야 하므로, 자바는 부동소수점을 저장할 때 전기전자기술자협회(IEEE)에서 개발한 IEEE754 명세에 따라 2진수로 변환한다. 

- 4바이트(32비트) float 타입(single-precision. 단정도)
  `[부호비트(1)][지수부(8)][가수부(23)]`
- 8바이트(64비트) double 타입(double-precision. 배정도)
  `[부호비트(1)][지수부(11)][가수부(52)]`
- 부호비트(sign bit) 

