---
layout: post
title: "[자바 문법] 리터럴"
categories:
  - Eomcs
tags:
  - 자바 문법


---

> - 2020-07-22 일자 수업 내용
> - [eomcs/eomcs-java](https://github.com/eomcs/eomcs-java) src/main/com/eomcs/lang/ex03
> - 자바의 정석 Chap2

# 리터럴

리터럴(literal)은 자바 언어로 표현된 값을 말한다. 자바에서 제공하는 리터럴 종류에는 다음과 같은 것들이 있다.

- **정수** 리터럴

  > **8, 16, 2진수 작성법**
  >
  > - 8진수는 숫자 맨 앞에 0을 적어서 작성한다.
  >
  > - 16진수는 숫자 맨 앞에 0x를 적어서 작성한다.
  >
  > - 2진수는 숫자 맨 앞에 0b를 적어서 작성한다.

  ```java
  System.out.println("-------- 정수 리터럴");
  System.out.println(78); // 10진수
  System.out.println(+78);
  System.out.println(-78);
  System.out.println(0116); // 8진수
  System.out.println(0x4e); // 16진수
  System.out.println(0b01001110); // 2진수
  ```

- **부동소수점** 리터럴

  ```java
  System.out.println("-------- 부동소수점 리터럴");
  System.out.println(3.14);
  System.out.println(31.4e-1);
  ```

- **논리** 리터럴

  ```java
      System.out.println("-------- 논리 리터럴");
      System.out.println(true);
      System.out.println(false);
  ```

  

- **문자** 리터럴

  ```java
      System.out.println("-------- 문자 리터럴");
      System.out.println('가');
  ```

- **문자열** 리터럴

  ```java
      System.out.println("-------- 문자열 리터럴");
      System.out.println("오호라 코딩스쿨!");
  ```

___

## 정수 리터럴

### 자릿수 표기

정수를 읽기 쉽도록 `_`를 숫자 사이에 삽입할 수 있다.

```java
    System.out.println(12783406);
    System.out.println(1278_3406);
    System.out.println(12_783_406);
```

`_`는 숫자 맨 앞 또는 맨 뒤에 삽입할 수 없다.

```java
    System.out.println(_12783406); 
    System.out.println(12783406_);

    // error!
```

자릿수 표기를 위한 `_`사용 규칙은 **2, 8, 16 진수**에도 동일하게 적용된다.

```java
    System.out.println(077);
    System.out.println(0_77);
    System.out.println(07_7);

    System.out.println(_077); // error!
    System.out.println(077_); // error!

    System.out.println(0b1100100);
    System.out.println(0b110_0100);
    System.out.println(0b1_1_0_0_1_0_0);

    System.out.println(0b_1100100); // error!
    System.out.println(0b1100100_); // error!

    System.out.println(0xffaa);
    System.out.println(0xff_aa);

    System.out.println(0x_ffaa); // error!
    System.out.println(0xffaa_); // error!
```

### 메모리 크기에 따른 표기법

정수를 저장할 메모리의 크기를 지정할 수 있다. 메모리의 크기에 따라 표현할 수 있는 정수의 크기가 다르다.

- 4 바이트 정수
  숫자에 접미사를 붙이지 않으면, 기본적으로 4 바이트 크기의 메모리에 저장되는 정수를 표현한다. 4 바이트로 표현할 수 있는 정수의 범위는 **-2^31^~ 2^31^-1**이다.

  ```java
      System.out.println(2147483647); // 4바이트 양의 정수 최대값
      System.out.println(-2147483648); // 4바이트 음의 정수 최소값
  ```

  이 메모리 크기를 초과하면 컴파일 오류가 발생한다.

  ```java
      System.out.println(2147483648); // error!
      System.out.println(-2147483649); // error!
  ```

- 8 바이트 정수
  4 바이트 메모리를 초과하는 정수 값을 표현할 떄 사용하며, 접미사 L 또는 l을 붙인다. 보통은 소문자  l이 숫자 1과 헷갈리기 때문에 대문자를 사용한다. 8 바이트로 표현할 수 있는 정수의 범위는 **-2^63^~ 2^63^-1**이다.

  ```java
      System.out.println(2147483648L); 
      System.out.println(-2147483649L); 
  ```

4 바이트 또는 8 바이트 정수의 최대값과 최소값을 외우기 번거롭기 때문에 자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 랩퍼 클래스에서 스태틱 필드로 값을 제공한다.

```java
    System.out.println(Integer.MAX_VALUE); // 2147483647
    System.out.println(Integer.MIN_VALUE); // -2147483648
    System.out.println(Long.MAX_VALUE); // 9223372036854775807
    System.out.println(Long.MIN_VALUE); // -9223372036854775808 
```

둘은 같은 값이라고 해도 차지하는 메모리의 크기가 다르다.

```java
    System.out.println(100); // 4바이트 크기의 정수 값 
    System.out.println(100L); // 8바이트 크기의 정수 값
```

### 메모리에 저장하는 방법

컴퓨터에서는 값을 저장할 때 전기 신호(예: RAM) 또는 자기 신호(예: HDD)로 저장한다. 값은 비트로 표현되고, 각 비트는 전기가 있거나 없거나 두 가지 상태로 구분된다. 비트의 두 가지 상태를 표현하기 위해서 2진수가 사용된다. 따라서 값을 메모리에 저장하려면 2진수로 표현될 수 있어야 한다.

### 정수를 2진수로 표현하는 방법

- 부호-절댓값(Sign-Magnitude)
  부동 소수점에서 가수부를 저장할 때 사용된다. 맨 왼쪽 1비트를 부호 비트로 사용되며 양수는 0, 음수는 1로 표현된다. 나머지 비트는 절댓값으로 저장된다.

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>+0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-0</td>
      <td>1000 0000</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1111 1101</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1111 1110</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1111 1111</td>
    </tr>
  </table>

  단점

  - 두 개의 0(+0, -0)이 존재한다.
  - 양수와 음수를 더했을 때 옳지 않은 값이 나온다.
    예) 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010 (-2)
  - 뺴기를 처리하는 컴퓨팅 회로를 별도로 설계해야 한다.

  장점

  - 이해하기 쉽다

- 1의 보수(Ones' Complement)
  음수의 모든 비트를 양수의 반대 값으로 바꾼다.

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>+0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-0</td>
      <td>1111 1111</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1111 1110</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1000 0010</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1000 0000</td>
    </tr>
  </table>

  단점

  - 두 개의 0이 존재한다.

  장점

  - 양수와 음수를 더하면 원래 값보다 1 작은 수가 나오는 경우가 발생한다.
    예) 5 + (-3) = 0000 0101 + 1111 1100 = 0000 0001 = 1

- 2의 보수(Two's complement)
  자바에서 음수를 저장하는 방법으로 1의 보수의 단점을 해결했다. 음수 0을 없앰으로써 8비트 기준 -128까지 표현이 가능하다.
  2의 보수를 만드는 방법

  1. 모든 비트를 반대 값으로 만든 다음 1을 더한다.
     0010 1001 => 1101 0110 =>1101 0111
  2. 오른쪽에서부터 1을 찾아, 찾은 1의 왼쪽편에 있는 모든 비트를 반대 값으로 바꾼다.
     0010 100**1** => **1101 011**1
  3. 2^n(8비트라면 2^8 = 256)에서 음수 값만큼 뺀다.
     41 => 256 - 41 = 215 = 1101 0111

  <table>
    <tr>
      <td>127</td>
      <td>0111 1111</td>
    </tr>
    <tr>
      <td>126</td>
      <td>0111 1110</td>
    </tr>
    <tr>
      <td>125</td>
      <td>0111 1101</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>0000 0001</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0000 0000</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>1111 1111</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-125</td>
      <td>1000 0011</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>1000 0010</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>1000 0001</td>
    </tr>
    <tr>
      <td>-128</td>
      <td>1000 0000</td>
    </tr>
  </table>

  장점

  - 양수와 음수의 덧셈이 정상 작동한다.
  - 음수 0이 없다.

- K-초과(Excess-K)
  부동 소수점의 지수부(exponent)를 저장할 때 사용한다. 오프셋 바이너리(offset binary) 또는 바이어스된 표기법(biased representation)이라고도 한다. K를 바이어스 값이라고 부르며, 표현하려는 값에 더할 때 사용한다.
  표현하려는 값 + 초과 값(K) = 결과
  바이어스 값(K)를 구하는 공식
  `K = 2^(비트수 - 1)`

  <table>
    <tr>
      <td>127</td>
      <td>1111 1111(128 + 127)</td>
    </tr>
    <tr>
      <td>126</td>
      <td>1111 1110(128 + 126)</td>
    </tr>
    <tr>
      <td>125</td>
      <td>1111 1101(128 + 125)</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1000 0001(128 + 1)</td>
    </tr>
    <tr>
      <td>0</td>
      <td>0000 0000(128 + 0)</td>
    </tr>
    <tr>
      <td>-1</td>
      <td>0111 1111(128 + (-1))</td>
    </tr>
    <tr>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <td>-126</td>
      <td>0000 0010(128 + (-126))</td>
    </tr>
    <tr>
      <td>-127</td>
      <td>0000 0001(128 + (-127))</td>
    </tr>
    <tr>
      <td>-128</td>
      <td>0000 0000(128 + (-128))</td>
    </tr>
  </table>

  >  IEEE 부동소수점 표준에서는 다음 공식을 사용한다.
  > `K = 2^(비트수 - 1) - 1`

  장점

  - 모든 비트가 0일 때 최소 값을 가지고, 모든 비트가 1일 때 최대 값을 갖기 때문에 작은 값에서 큰 값으로 정렬되는 결과를 낳는다. 
  - 모든 비트가 정렬되므로 값을 비교할 때 속도가 빠르다.

### 자바에서 정수를 메모리에 저장하는 방법

`2의 보수`를 사용하여 정수 리터럴을 표현한다. 정수 리터럴은 각각 4바이트와 8바이트 크기의 메모리를 차지하므로 다음과 같이 메모리에 저장된다.

예시)
23  = 0000 0000 0000 0000 0000 0000 0001 0111
-23 = 1111 1111 1111 1111 1111 1111 1110 1001

____

## 부동소수점 리터럴

> **부동소수점(Floating Point)이란?** 
> [실수](https://ko.wikipedia.org/wiki/실수)를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, [유효숫자](https://ko.wikipedia.org/wiki/유효숫자)를 나타내는 가수(假數)와 소수점의 위치를 풀이하는 지수(指數)로 나누어 표현한다. 
> 출처: [https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90#:~:text=%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90(%E6%B5%AE%E5%8B%95%E5%B0%8F%E6%95%B8%E9%BB%9E,%E6%8C%87%E6%95%B8)%EB%A1%9C%20%EB%82%98%EB%88%84%EC%96%B4%20%ED%91%9C%ED%98%84%ED%95%9C%EB%8B%A4](https://ko.wikipedia.org/wiki/부동소수점#:~:text=부동소수점(浮動小數點,指數)로 나누어 표현한다).

### 표기법

부동소수점 리터럴은 자바에서 다음과 같이 표현 가능하다.

- 10진수

```java
System.out.println(3.14);
```

- Exponential 기호 사용
  e 기호를 사용하면 소수점의 위치를 조정할 수 있다. 소수점의 위치를 이처럼 움직인다고 해서 부동소수점이라고 부른다. e는 대문자 혹은 소문자로 모두 표기가 가능하다.

```java
    System.out.println(0.0314e2); // 0.0314 * 10의2승 = 3.14
    System.out.println(0.314e1); // 0.314 * 10의1승 = 3.14
    System.out.println(31.4e-1); // 31.4 * 10의-1승 = 3.14
    System.out.println(314e-2); // 314 * 10의-2승 = 3.14
```

### 메모리 크기에 따른 표기법

정수 리러털과 마찬가지로 부동소수점 리터럴도 저장할 메모리의 크기를 지정할 수 있다. 메모리의 크기에 따라 표현할 수 있는 부동소수점의 크기가 다르다.

- 4 바이트
  숫자 맨 뒤에 f 또는 F를 붙인다. 주로 소문자를 많이 붙인다. 4 바이트로 저장가능한 값의 범위는 1.4 x 10^-45^ ~ 3.4 x 10^38^이지만 정밀도는 7자리기 때문에, 그 이상으로는 정확한 수를 표현할 수 없다.

  ```java
      System.out.println(3.14f);
      System.out.println(3.14F);
  ```

- 8 바이트
  숫자 맨 뒤에 d 또는 D를 붙인다. 생략을 해도 된다. 8 바이트로 저장가능한 값의 범위는 4.9 x 10^-324^ ~ 1.8 x 10^308^이지만 정밀도는 15자리기 때문에, 그 이상으로는 정확한 수를 표현할 수 없다.

  ```java
      System.out.println(3.14);
      System.out.println(3.14d);
      System.out.println(3.14D);
  ```

정수 리터럴과 마찬가지로 자바에서는 각 데이터 유형에 따라 최대/최소 값을 알아볼 수 있도록 랩퍼 클래스에서 스태틱 필드로 값을 제공한다.

```java
    System.out.println(Float.MAX_VALUE); // 3.4 x 10^38
    System.out.println(Float.MIN_VALUE); // 1.4 x 10^-45
    
    System.out.println(Double.MAX_VALUE); // 1.8 x 10^308
    System.out.println(Double.MIN_VALUE); // 4.9 x 10^-324
```

### 유효자릿수

정수처럼 메모리 크기에 따라 표현할 수 있는 부동소수점의 범위가 다르다. IEEE754 명세에 따라 2진수로 변환되므로 저오학하게 소수점 이하 얼마까지 정의할 수 없다. 대신 `유효자릿수`라는 방식으로 대략적으로 값의 범위를 표현한다.

4바이트(float) 부동소수점의 유효자릿수는 소수점을 빼고 7자리이므로 7자리 숫자까지는 거의 정상 작동한다.

```
    System.out.println(999.9999f); // 999.9999
    System.out.println(999999.9f); // 999999.9
    System.out.println(9.999999f); // 9.999999
```

유효자릿수가 7자리를 넘어가는 경우 값이 잘려서 저장될 수가 있다.

```java
    System.out.println(987654321.1234567f); // 9.8765434E8
    System.out.println(9.876543211234567f); // 9.876543
    System.out.println(987654321123456.7f); // 9.876543E14
```

8바이트(double) 부동소수점의 유효자릿수는 소수점을 빼고 15자리이므로 15자리 숫자까지는 거의 정상 작동한다.

```java
    System.out.println(987654321.1234567); // 9.876543211234567E8
    System.out.println(9.876543211234567); // 9.876543211234567
    System.out.println(987654321123456.7); // 9.876543211234568E14
```

유효자릿수가 15자리를 넘어가는 경우 값이 잘려서 저장될 수 있다.

```java
    System.out.println(987654321.12345678); // 9.876543211234568E8
    System.out.println(9.8765432112345678); // 9.876543211234567
    System.out.println(987654321123456.78); // 9.876543211234568E14

```

유효자릿수가 7, 16자리를 넘지 않더라도 부정확하게 저장되는 경우가 가끔 있다.

```java
    System.out.println(7 * 0.1); // 0.7000000000000001
```

이러한 오류가 발생하는 이유는 IEEE-754 규격에 따라 부동소수점을 2진수로 바꾸다보면 정확하게 2진수로 떨어지지 않는 경우가 있기 때문이다. 

### 부동소수점을 2진수로 표현하는 방법

실수 값을 부동소수점 방식으로 저장하려면 1과 0으로 변환해야 하므로, 자바는 부동소수점을 저장할 때 전기전자기술자협회(IEEE)에서 개발한 IEEE754 명세에 따라 2진수로 변환한다. 

메모리 크기에 따라 부동소수점은 다음과 같은 2진수로 변환된다. 

- 4바이트(32비트) float 타입(single-precision. 단정도)
  `[부호비트(1)][지수부(8)][가수부(23)]`
- 8바이트(64비트) double 타입(double-precision. 배정도)
  `[부호비트(1)][지수부(11)][가수부(52)]`

이 2진수를 이루는 것은 각각 부호비트와 지수, 가수이다. 각각의 요소를 작성하는 방법은 다음과 같다. (12.375(10진수) => 4바이트 2진수 변환 예시)

1. 12.375를 2진수로 변환한다. => 1100.0111 (2)

   - 정수 부분을 2진수로 변환한다.

     ```
     12(10진수) = 1100(2진수)
     ```

   - 소수 부분을 2진수로 변환한다.
     소수를 2진수로 변환하려면 소수부분이 0이되거나 반복될 때까지 2로 곱하여 나온 결과에서 정수 부분만을 차례대로 표기한다.

     ```j
     0.375 * 2 = 0.75 --> 0
     0.75  * 2 = 1.5  --> 1
     0.5   * 2 = 1.0  --> 1
     => 0.011(2진수)
     ```

2. 정규화 과정을 거친다. =>` [0][10000010][10001100000000000000000]` = 0x41460000
   소수점의 위치를 조정하여 가수부와 지수를 분리하는 과정을 정규화라고 한다. IEEE 754 명세는 다음과 같은 형식으로 가수부와 지수부를 나눈다. 

   - 소수점 왼쪽에 1만 남도록 소수점을 이동한다.

     ```
     1.100011 * 2^3
     ```

   - 소수점 오른쪽 수들이 가수부가 되고,  2의 지수가 지수부가 된다. 가수부는 가수부로 정해진 비트수만큼만 저장되고, 나머지는 버려진다. 만약 비트를 모두 채우지 못하면 나머지 비트는 0으로 채워진다. 지수부도 2진수로 변환되며 정해진 비트수만큼만 저장되며, 비트를 모두 채우지 못할 경우 오른쪽부터 0으로 채워진다.

     ```
     가수부 = 100011
     지수부 = 3 + 127 = 130(10) = 10000010(2)
     ```

유효 자릿수의 부동 소수점이라도 정규화하면 2진수로 떨어지지 않은 경우는 가수부가 2진수로 완벽히 표현되지 못하는 경우이다. 이러한 경우에는 0.00000...1 의 아주 작은 오차가 발생한다. 

```
0.127 => 
0.127 * 2 = 0.254 --> 0
0.254 * 2 = 0.508 --> 0
0.508 * 2 = 1.016 --> 1
0.016 * 2 = 0.032 --> 0
0.032 * 2 = 0.064 --> 0
0.064 * 2 = 0.128 --> 0
0.128 * 2 = 0.256 --> 0
0.256 * 2 = 0.512 --> 0
0.512 * 2 = 1.024 --> 1
0.024 * 2 = 0.048 --> 0
.
.
.
```

____

## 문자 리터럴

작은 따옴표 ' '를 사용하여 문자를 표현한다. 자바는 문자를 메모리에 저장할 때 Unicode 규칙에 따라 2바이트 코드로 저장된다. 이 2바이트 코드를 `문자 코드(charater code)`라고 부른다. 만약 어떤 문자열을 출력한다면 해당 코드의 문자를 폰트 파일에서 찾아 출력한다. 먄약 폰트 파일에 해당 코드의 문자가 없다면 출력하지 못한다.

```java
    System.out.println('A'); // A
    System.out.println('가'); // 가
```

문자를 적는 대신에 직접 문자 코드를 통해 표현할 수도 있다. 코드 값은 사용하는 문자 집합에 따라 다르다. 자바는 `Unicode(UTF-16BE, UCS2)`라는 문자집합을 사용하므로 이를 확인하여 사용해야 한다. 문자코드를 작성할 때에는 `\u`를 앞에 붙여주고 16진수의 형태로 뒤에 코드값을 적는다.

```java
    System.out.println('\u0041');  // A
    System.out.println('\uac00');  // 가
    System.out.println('\uAC00');  // 가 
```

다음과 같이 `\`을 앞에 붙이고, 8진수로르 적는 것도 가능하다.

```java
    System.out.println('\101'); // A
    System.out.println('\122'); // z
    System.out.println('\377'); // ÿ
```

보통 키보드로 입력하기 힘든 문자를 표현할 때 유니코드를 직접 적어 사용한다.

```java
    System.out.println('\u4eba'); //人
    System.out.println('\u00a9'); // ©
    System.out.println('\u03c0'); // π
    System.out.println('\u03a3'); // Σ
```

### 유니코드

전 세계의 모든 문자를 컴퓨터에서 일관되게 처리할 목적으로 정의된 산업 표준 규칙이다. 유니코드는 문자를 2진수로 표현할 때 두 가지 방식(UTF/UCS)을 사용한다. 자바는 메모리에 문자를 저장할 때는 UCS-2를 사용하고, 외부로 입출력할 때에는 주로 UTF-8를 사용한다. 

> **UTF-8**
> 의 코드 값 중에서 00~7F(127)까지 ASCII에 해당하는 UCS 코드는 그대로 1바이트로 표현된다. 따라서 ASCII를 기본으로 하는 시스템의 경우에는 UTF-8로 인코딩된 데이터(알파벳, 숫자 등)를 그대로 읽고 쓸 수 있다. 그 외의 문자 코드는 규칙에 따라 2바이트 ~ 4바이트까지 변환하여 표현한다. 따라서 각 문자들에 따라 바이트 크기가 1바이트에서 4바이트까지 유동적으로 변한다. 
>
> ```
> 000000 ~ 00007F: 0xxxxxxx
> 000080 ~ 0007FF: 110yyyxx 10xxxxxx
> 000800 ~ 00FFFF: 1110yyyy 10yyyyxx 10xxxxxx
> 100000 ~ 10FFFF: 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx 
> ```
>
> 대부분의 시스템에서 데이터를 입출력할 때 UTF-8을 사용하고 있다. 

> **UTF-16**
> UCS-2의 코드 값은 그대로 2바이트로 표현되며, ASCII 코드도 UCS-2와 동일하게 2바이트로 표현된다. UCS-2와 다른 점은 UCS-2 범위를 벗어나는 문자 코드 값은 4바이트로 확장되어 변환된다는 점이다.
>
> ```
> 000000 ~ 00007F: 00000000 0xxxxxxx
> 000080 ~ 0007FF: 00000yyy xxxxxxxx
> 000800 ~ 00FFFF: yyyyyyyy xxxxxxxx
> 100000 ~ 10FFFF: 110110zz zzyyyyyy 110111yy xxxxxxxx 
> ```

> **UTF-32**
> UCS-4의 4바이트 코드 값을 그대로 표현하므로 UCS-4와 같다. 그러나 모든 문자를 4바이트 코드 값으로 표현하기 때문에 메모리 낭비가 심하다.

### 문자를 2진수로 변환하는 규칙

1. `ASCII(7bit)`
   미국 국가 표준 협회 (ANSI)에서 영어 알파벳, 숫자, 특수 문자 등을 컴퓨터에서 저장할 수 있도록 7비트 2진수로 정의한 인코딩 규칙이다.
   [(ASCII 변환표 참고)](http://web.alfredstate.edu/faculty/weimandn/miscellaneous/ascii/ascii_index.html)

   > **줄바꿈 코드**
   > 윈도우 OS에서는 CR과 LF를 두 바이트를 사용하여 줄바꿈을 표시하지만 그 이외의 Mac, Linux, Unix에서는 LF만을 이용하여 줄 바꿈을 표시한다.

2. `ISO-8859-1`
   HTML 문서의 기본 인코딩이며 ASCII에 유럽문자까지 포함된 국제 표현 문자 인코딩이다. 가장 널리 사용되며 서유럽 언어를 지원한다.

3. `EUC-KR`
   국제 표준 한글 문자 집합이며, 한글 음절 한 개에 대해 인코딩 규칙을 정의했지만, 현재 유통되는 모든 한글 음절을 표현하지는 못한다. (예- '똠')

4. `MS949`
   윈도우 OS의 인코딩 규칙이며, EUC-KR에서 표현하지 못한 몇가지 음절을 보충했다. 기존의 EUC-KR에서 몇가지만 추가한 형태이기 때문에 정렬할 때 순서가 올바르게 정렬되지 않는다는 문제가 있다.

5. `Unicode`
   국제 표준 인코딩 규칙이다. UCS-2의 경우, 영어, 한글 모두 2바이트로 인코딩한다. MS-949의 모든 한글 문자가 포함되어있다. EUC-KR, UCS-2와 호환되지 않는다. JVM은 내부에서 문자열을 다룰 때 UCS-2를 사용하므로 모두 2바이트로 저장된다.

6. `UTF-8(1~4바이트)`
   기존 영어권 시스템에서 유니코드 문자를 사용하기 위해 탄생했다. 즉, 영어를 1바이트로 표현하는 ISO-8859-1규칙에서 모든 것을 2바이트로 표현하는 유니코드를 다루기 위해 유니코드와 호환이되면서 1바이트로 영어를 표현할 수 있는 UTF-8을 만든 것이다.
   한글은 UTF-8에서 0800~ffff 범위에 있으므로 3바이트로 변환된다.

### 작은 따옴표

작은 따옴표는 문자 리터럴을 표현할 때 문자의 코드 값을 알려주는 도구이다. 즉, 작은 따옴표 사이에 유니코드를 넘기거나, 혹은 그 문자 자체를 넘겨주면 그것을 문자로 인식하여 유니코드 값을 메모리에 저장하는 것이다. 즉 작은 따옴표는 데이터 형을 알려주는 (char)의 역할과 유사하다.

```java
System.out.println('\u0041'); // A
System.out.println('A');      // A
System.out.println((char)65); // A
```

만약 작은 따옴표가 알려준 유니코드 앞에 (int)를 붙인다면 유니코드 값을 정수 형태로 표시할 수가 있다.

```java
System.out.println((int)'A'); // 65
```

따라서 작은 따옴표가 알려준 유니코들 갖고 다른 숫자와 연산도 가능하다.

```java
System.out.println('각' + 1); // 44034
System.out.println('각' - 1); // 44032
```

해당 계산 결과를 또다시 문자의 형태로 바꾸고 싶다면 이전에 했던대로 (char)을 붙이면 된다.

``` java
System.out.println((char)('각' + 1)); // 갂
System.out.println((char)('각' - 1)); // 가
```

___

## 논리값 리터럴

논리값 리터럴은 참, 거짓을 표현할 때 사용된다. 자바는 대소문자를 구분하므로 소문자로, 참은 true, 거짓은 false로 각각을 표현한다. 

```java
System.out.println(true);  // true
System.out.println(false); // false
```

 비교 연산의 결과는 논리값이다.

```java
System.out.println(4 < 5); // true
System.out.println(4 > 5); // false
```

논리 연산의 결과도 노리값이다.

```java
System.out.println(true && false);
System.out.println(true || false);
```

숫자를 true나 false로 변환할 수는 없다.

```java
System.out.println((boolean)1); // 컴파일 오류!
```

### 논리값을 메모리에 저장하는 방법

기본적으로는 4바이트 int 메모리에 저장하지만 배열의 요소인 경우에는 1바이트에 저장한다. true는 1, false는 0으로 저장하지만, 위에서 확인한 것처럼 직접 정수 값을 지정해서는 안된다. 

___

##  문자열 리터럴

문자열 리터럴은 자바의 기본 타입이 아닌 객체이다. 큰 따옴표 안에 문자들을 작성함으로써 사용이 가능하다. 문자들의 나열이므로 문자 대신 유니코드를 직접 작성할 수 있다.

```java
    System.out.println("ABC가나다");
    System.out.println("\u0041BC\uac00나다");
```

### 문자열 연결 연산자(concatenation)

두 개 이상의 문자열을 연결할 수 있는 연결 연산자 +가 자바에서 제공된다. 문자열과 문자열은 물론, 문자열과 다른 종류의 값도 연겨링 가능하며, 연결되기 전에 다른 종류의 값이 문자열로 변환된 후 연결된다.  부동소수점이 문자열로 변환되면 접미사는 뒤에 붙지 않는다.

```java
System.out.println("Hello," + "world!"); // Hello,world!
System.out.println("나이:" + 20); // 나이:20
System.out.println(false + "<== 재직자 여부"); // false<== 재직자 여부
System.out.println("성별:" + '여'); // 성별:여
System.out.println("키:" + 170.5f); // 키:170.5
```

### 이스케이프 문자(escape character)

이스케이프 문자는 문자 제어 코드로, 화면에 출력되는 문자가 아닌 문자의 출력을 제어하는 특별한 문자이다. 이스케이프 문자에는 다음과 같은 것들이 있다.

- `\n` : Line Feed(LF), 0x0a
  줄바꿈 문자

  ```java
  System.out.println("Hello,world!"); 
  // world!
  // Hello,
  ```

- `\r` : Carrage Return(CR), 0x0d
  커서를 해당 줄 가장 앞으로 돌리는 문자

  ```java
  System.out.println("Hello,\rabc"); // abclo,
  ```

- `\f` : Form Feed(FF), 0x0c
  프린터가 용지의 한 페이지 길이에 해당하는 만큼 페이지를 넘기거나 다음 페이지의 제일 첫 부분으로 넘기는 문자
  
  ```java
System.out.println("Hello,\fworld!");
  ```
  
- `\t` : Tab, 0x09
   탭 공간을 추가시키는 문자

  ```java
  System.out.println("Hello,\tworld!"); // Hello,	world!
  ```

- `\b` : Backspace, 0x08
  커서를 뒤로 한 칸 이동시키는 문자

  ```java
  System.out.println("Hello,\b\b\bworld!"); // Hellworld!
  ```

- `\'` : Single Quote, 0x27
  작은 따옴표를 출력시키는 문자, 큰 따옴표 안에서는 이스케이프 문자를 사용할 필요없이 그냥 작은 따옴표를 적으면 되지만, 작은 따옴표 안에서 적을 경우에는 이스케이프 문자가 필요하다.

  ```java
  System.out.println("Hello,'w'orld!"); // Hello,'w'orld!
  System.out.println('\''); // '
  ```

- `\"` : Double Quote, 0x22
  작은 따옴표와 마찬가지로 작은 따옴표 안에서 큰 따옴표를 적을 때는 그냥 적으면 되지만, 큰 따옴표 안에서 큰 따옴표를 적고 싶을 때에는 이스케이프 문자를 사용해야 한다.

  ```java
  System.out.println('"'); // "
  System.out.println("Hello,\"w\"orld!"); // Hello,"w"orld!
  ```

- `\\` : Backslask, 0x5c
  이스케이프 문자의 시작 문자로 항상 백슬래시가 사용되기 때문에 백슬래시를 일반 문자로 사용하고 싶다면 백슬래시를 두 번 연속 적어야 한다.

  ```java
  System.out.println("c:\\Users\\user\\git"); // c:\Users\user\git
  ```

  